# -*- coding: utf-8 -*-
"""2*5_Puzzle_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FRk08ycvnhV-slUPqNeqfbOD44SyWJny
"""

import random
import copy
import heapq
import time

ROWS, COLS = 2, 5
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1)]
goal_state = [
    [1, 2, 3, 4, 5],
    [6, 7, 8, 9, 0]
]

# 상태를 튜플로 변환
def state_to_tuple(state):
    return tuple(tuple(row) for row in state)

# 상태를 1차원 배열로 평탄화
def flatten(state):
    return [num for row in state for num in row]

# 퍼즐이 풀 수 있는 상태인지 검사 (inversion count 방식)
def is_solvable(state):
    flat = flatten(state)
    inversion_count = 0
    for i in range(len(flat)):
        for j in range(i + 1, len(flat)):
            if flat[i] != 0 and flat[j] != 0 and flat[i] > flat[j]:
                inversion_count += 1
    return inversion_count % 2 == 0

# 빈칸 위치
def find_zero(state):
    for r in range(ROWS):
        for c in range(COLS):
            if state[r][c] == 0:
                return r, c
    return -1, -1

# 중복되는 상태 검사 및 탐색 함수
def search_puzzle_algorithm(start_state, search_type='a_star', log_moves=False):
    start_time = time.time()
    if not is_solvable(start_state):
        print("❌ 이 퍼즐은 해결할 수 없는 상태입니다.")
        return None, None, 0, 0

    visited = set()
    open_list = []
    # 큐에서 상태를 꺼낼 때마다 중복된 상태를 처리하지 않기 위한 구조 추가
    best_g = {}  # 최단 경로값 기록 (g값이 더 작은 경로만 큐에 추가)

    # 초기 상태를 큐에 넣음 (A*와 다익스트라는 동일하게 힙을 사용)
    if search_type == 'a_star':
        heapq.heappush(open_list, (manhattan_distance(start_state), 0, start_state, []))  # (f = g + h, g, state, path)
    elif search_type == 'dijkstra':
        heapq.heappush(open_list, (0, start_state, []))  # (g, state, path)
        best_g[state_to_tuple(start_state)] = 0

    while open_list:
        # 우선순위 큐에서 상태를 꺼냄
        if search_type == 'a_star':
            f, g, state, path = heapq.heappop(open_list)
        elif search_type == 'dijkstra':
            g, state, path = heapq.heappop(open_list)

        state_key = state_to_tuple(state)

        # 방문한 상태는 건너뛰기
        if state_key in visited:
            continue
        visited.add(state_key)

        # 목표 상태에 도달한 경우
        if state == goal_state:
            end_time = time.time()
            if log_moves:
                print("Solution Path:")
                for i, step in enumerate(path, 1):
                    print(f"{i}. {step}")
            return path, state, end_time - start_time, len(path)

        zr, zc = find_zero(state)
        for dr, dc in MOVES:
            nr, nc = zr + dr, zc + dc
            if 0 <= nr < ROWS and 0 <= nc < COLS:
                new_state = copy.deepcopy(state)
                new_state[zr][zc], new_state[nr][nc] = new_state[nr][nc], new_state[zr][zc]
                move_description = f"Move {new_state[zr][zc]} to ({zr},{zc})"

                new_state_key = state_to_tuple(new_state)
                new_g = g + 1  # 새로운 경로의 g값

                # 새로운 상태가 더 좋은 경로라면 큐에 추가
                if new_state_key not in best_g or new_g < best_g[new_state_key]:
                    best_g[new_state_key] = new_g
                    # A*의 경우 f = g + h를, Dijkstra는 g만 사용
                    if search_type == 'a_star':
                        heapq.heappush(open_list, (new_g + manhattan_distance(new_state), new_g, new_state, path + [move_description]))
                    elif search_type == 'dijkstra':
                        heapq.heappush(open_list, (new_g, new_state, path + [move_description]))

    return None, None, 0, 0

# 무작위 퍼즐 생성
def generate_random_state():
    nums = list(range(10))
    random.shuffle(nums)
    return [nums[i*COLS:(i+1)*COLS] for i in range(ROWS)]

# 실행 예시
if __name__ == "__main__":
    while True:
        initial_state = generate_random_state()
        print("Initial State:")
        for row in initial_state:
            print(row)

        if is_solvable(initial_state):
            print("✅ 이 퍼즐은 해결 가능한 상태입니다.")
            break
        else:
            print("❌ 이 퍼즐은 해결 불가능한 상태입니다. 새로운 퍼즐을 생성합니다.\n")

    # A* 알고리즘 실행
    path_a_star, final_state_a_star, time_a_star, moves_a_star = search_puzzle_algorithm(initial_state, search_type='a_star', log_moves=False)
    if path_a_star:
        print(f"\nA* Algorithm Result:")
        print(f"Minimum Moves: {moves_a_star}")
        print(f"Execution Time: {time_a_star:.4f} seconds")

    # 다익스트라 알고리즘 실행
    path_dijkstra, final_state_dijkstra, time_dijkstra, moves_dijkstra = search_puzzle_algorithm(initial_state, search_type='dijkstra', log_moves=False)
    if path_dijkstra:
        print(f"\nDijkstra Algorithm Result:")
        print(f"Minimum Moves: {moves_dijkstra}")
        print(f"Execution Time: {time_dijkstra:.4f} seconds")